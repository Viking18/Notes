##一、内存模型

###native 方法

是 Java 调用非 Java 代码的一个方法，其实现了 JNI (Java Native Interface) 的接口规则。

优点：有些代码利用 C/C++ 实现可能更为简洁。与底层的操作系统等交互是，也无需关注 Java 之外的繁琐的部分。有些业务相关的代码，利用 Java 来实现不方便，或者需要重构。

缺点：失去了 Java 跨平台的优势，native 方法在跨平台之后需要重新编译。

###Java 虚拟机栈

这是线程私有的。每个方法在执行的时候会创建一个栈帧（ Stack Frame ） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的调用直至执行完成，其实就是一个栈帧在虚拟机栈的入栈与出栈过程。

虚拟机栈有两种异常：一是当线程请求的栈深度大于虚拟机允许的最大深度时，将抛出 StackOverflowError 异常；二是如果虚拟机栈的大小是可以动态扩展的（目前大部分可以），如果扩展无法申请到足够内存，将会抛出 OutOfMemoryError 异常。

###本地方法栈

与 Java 虚拟机栈类似，只不过本地方法栈是为了调用本地方法服务的。有些虚拟机中将其与虚拟机栈合二为一（如 Sun HotSpot 虚拟机）。

### Java 堆

对于大多数应用 ，Java 堆（ Java Heap ）是 Java 虚拟机所管理的内存中最大的一块。它是所有线程共享的，它的唯一作用就是存放程序运行时的对象实例（对象的引用会存放在虚拟机栈的局部变量表中），几乎所有的实例都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，有时也称为“ GC 堆”（ Garbage Collecting Heap ）。它不需要物理上连续的内存区，涉及到后面的清理方法。如果扩展不到足够的内存，会抛出 OutOfMemoryError 异常。

### 方法区

它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。对方法区也应实现内存回收，但是回收效率低收效少。如果无法满足内存需求，会抛出 OutOfMemoryError 异常。





